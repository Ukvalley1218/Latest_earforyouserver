// import mongoose from 'mongoose';
// import CallLog from '../models/Talk-to-friend/callLogModel.js';
// import logger from '../logger/winston.logger.js';
// import sendNotification from '../utils/sendNotification.js';
// import User from '../models/Users.js';
// // import handleCallRecording  from './Recording.js'
// import Wallet from '../models/Wallet/Wallet.js';


// export const setupWebRTC = (io) => {
//   // Store active users and their socket connections
//   const users = {}; // { userId: [socketId1, socketId2, ...] }
//   const activeCalls = {}; // { userId: otherUserId }
//   const randomCallQueue = new Set();
//   const callTimers = {}; // Store intervals for billing
//   const callConnections = {};
//   const RATE_PER_MINUTE = 10;
//   const BILLING_INTERVAL = 60000; // 1 minute
//   const MINIMUM_BALANCE = RATE_PER_MINUTE;

//   const startBilling = async (callerId, receiverId, socket) => {
//     // Generate a unique transaction ID for this billing cycle
//     const transactionId = `CALL-${callerId}-${receiverId}-${Date.now()}`;
  
//     const timerId = setInterval(async () => {
//       const session = await mongoose.startSession();
//       try {
//         await session.withTransaction(async () => {
//           const callerWallet = await Wallet.findOne({ userId: callerId }).session(session);
  
//           // Check for insufficient balance
//           if (!callerWallet || callerWallet.balance < RATE_PER_MINUTE) {
//             clearInterval(callTimers[callerId]);
//             delete callTimers[callerId];
  
//             // Notify both parties about insufficient balance
//             socket.emit('callEnded', {
//               reason: 'Insufficient balance',
//               remainingBalance: callerWallet?.balance || 0
//             });
  
//             if (users[receiverId]) {
//               users[receiverId].forEach((socketId) => {
//                 io.to(socketId).emit('callEnded', {
//                   callerId,
//                   reason: 'Insufficient balance'
//                 });
//               });
//             }
  
//             // Clean up call status
//             delete activeCalls[callerId];
//             delete activeCalls[receiverId];
  
//             return;
//           }
  
//           // Verify payment through PhonePe before proceeding
//           const paymentStatus = await verifyPaymentWithPhonePe(transactionId); // Verify using the dynamic transaction ID
//           if (!paymentStatus) {
//             throw new Error('Payment verification failed');
//           }
  
//           // Process billing
//           const adminCommissionPercent = 10;
//           const totalDeduction = RATE_PER_MINUTE;
//           const commission = (adminCommissionPercent / 100) * totalDeduction;
//           const amountForReceiver = totalDeduction - commission;
  
//           // Update caller's wallet
//           callerWallet.balance -= totalDeduction;
//           callerWallet.deductions.push({
//             amount: totalDeduction,
//             deductionReason: 'call',
//             callId: `${callerId}-${receiverId}-${Date.now()}`,
//             createdAt: new Date()
//           });
  
//           // Update receiver's wallet
//           const receiverWallet = await Wallet.findOne({ userId: receiverId }).session(session);
//           if (receiverWallet) {
//             receiverWallet.balance += amountForReceiver;
//             receiverWallet.recharges.push({
//               amount: amountForReceiver,
//               rechargeMethod: 'call_earning',
//               transactionId: `CALL-${Date.now()}`,
//               createdAt: new Date()
//             });
//             await receiverWallet.save({ session });
  
//             // Notify receiver about earnings
//             if (users[receiverId]) {
//               users[receiverId].forEach((socketId) => {
//                 io.to(socketId).emit('earningsUpdate', {
//                   amount: amountForReceiver,
//                   newBalance: receiverWallet.balance
//                 });
//               });
//             }
//           }
  
//           await callerWallet.save({ session });
  
//           // Notify caller about balance update
//           socket.emit('balanceUpdate', {
//             newBalance: callerWallet.balance,
//             deduction: totalDeduction,
//             timestamp: Date.now()
//           });
//         });
//       } catch (error) {
//         logger.error(`Billing error: ${error.message}`);
//         clearInterval(callTimers[callerId]);
//         delete callTimers[callerId];
//         socket.emit('callError', { message: 'Billing error occurred' });
//       } finally {
//         if (session) {
//           session.endSession();
//         }
//       }
//     }, BILLING_INTERVAL);
  
//     callTimers[callerId] = timerId;
//   };
  
//   // Function to verify payment with PhonePe
//   const verifyPaymentWithPhonePe = async (transactionId) => {
//     try {
//       // Prepare the request URL and payload
//       const apiUrl = 'https://api.phonepe.com/v1/transaction'; // Replace with the actual PhonePe API URL
//       const headers = {
//         'Content-Type': 'application/json',
//         // Include authentication headers if required
//         // 'Authorization': 'Bearer YOUR_ACCESS_TOKEN',
//       };
  
//       const response = await axios.get(`${apiUrl}/${transactionId}`, { headers });
  
//       // Check the response to see if the payment is successful
//       if (response.data && response.data.status === 'SUCCESS') {
//         return true; // Payment is successful
//       } else {
//         return false; // Payment failed or status is not SUCCESS
//       }
//     } catch (error) {
//       console.error(`Payment verification error: ${error.message}`);
//       return false; // Return false in case of any error
//     }
//   };
  

//   io.on('connection', (socket) => {
//     logger.http(`User connected: ${socket.id}`);

//     socket.on('join', async ({ userId }) => {
//       if (!users[userId]) {
//         users[userId] = [];
//       }
//       users[userId].push(socket.id);
//       logger.info(`User ${userId} joined with socket ID ${socket.id}`);
//     });

//     socket.on('call', async ({ callerId, receiverId }) => {
//       try {
//         logger.info(`User ${callerId} is calling User ${receiverId}`);

//         // Check caller's balance
//         const callerWallet = await Wallet.findOne({ userId: callerId });
//         if (!callerWallet || callerWallet.balance < MINIMUM_BALANCE) {
//           socket.emit('callError', {
//             message: 'Insufficient balance to start call',
//             remainingBalance: callerWallet?.balance || 0
//           });
//           return;
//         }

//         // Check if users are already in calls
//         if (activeCalls[receiverId] || activeCalls[callerId]) {
//           socket.emit('userBusy', { receiverId });
//           return;
//         }

//         const [caller, receiver] = await Promise.all([
//           User.findById(callerId),
//           User.findById(receiverId)
//         ]);

//         if (!receiver || !caller) {
//           socket.emit('userUnavailable', { receiverId });
//           return;
//         }

//         // Initialize user socket arrays
//         if (!users[callerId]) users[callerId] = [];
//         if (!users[receiverId]) users[receiverId] = [];

//         if (!users[callerId].includes(socket.id)) {
//           users[callerId].push(socket.id);
//         }

//         if (users[receiverId].length > 0) {
//           // Notify receiver about incoming call
//           users[receiverId].forEach((socketId) => {
//             io.to(socketId).emit('incomingCall', {
//               callerId,
//               callerName: caller.username,
//               socketId: socket.id
//             });
//           });

//           socket.emit('playCallerTune', { callerId });

//           // Send push notification
//           if (receiver.deviceToken) {
//             await sendNotification(
//               receiver.deviceToken,
//               'Incoming Call',
//               `${caller.username} is calling you!`
//             );
//           }
//         } else {
//           socket.emit('userUnavailable', { receiverId });
//         }
//       } catch (error) {
//         logger.error(`Error in call handler: ${error.message}`);
//         socket.emit('callError', { message: 'Failed to initiate call' });
//       }
//     });

//     // Object to maintain connection states


//     socket.on('offer', ({ offer, callerId, receiverId }) => {
//       try {
//         logger.info(`Offer from ${callerId} to ${receiverId}`);
//         activeCalls[callerId] = receiverId;
//         activeCalls[receiverId] = callerId;

//         // Initialize the call connection state
//         callConnections[callerId] = { connected: false };

//         if (users[receiverId]) {
//           users[receiverId].forEach((socketId) => {
//             io.to(socketId).emit('offer', { offer, callerId });
//           });
//         }
//       } catch (error) {
//         logger.error(`Error in offer handler: ${error.message}`);
//         socket.emit('callError', { message: 'Failed to process offer' });
//       }
//     });

//     socket.on('answer', async({ answer, receiverId, callerId }) => {
//       try {
//         const callerWallet = await Wallet.findOne({ userId: callerId });
//         if (!callerWallet || callerWallet.balance < MINIMUM_BALANCE) {
//           socket.emit('callError', {
//             message: 'Insufficient balance to start call',
//             remainingBalance: callerWallet?.balance || 0
//           });
//           return;
//         }

//         if (users[callerId]) {
//           users[callerId].forEach((socketId) => {
//             io.to(socketId).emit('answer', { answer, receiverId });
//           });

//           // Update the connection state to true
//           callConnections[callerId].connected = true;
//           callConnections[receiverId].connected = true;
          
//           startBilling(callerId, receiverId, socket);
//           // Emit a connected event
//           io.to(callerId).emit('callConnected', { message: 'Call connected', callerId, receiverId });
//           io.to(receiverId).emit('callConnected', { message: 'Call connected', callerId, receiverId });
//         }
//       } catch (error) {
//         logger.error(`Error in answer handler: ${error.message}`);
//         socket.emit('callError', { message: 'Failed to process answer' });
//       }
//     });

//     socket.on('iceCandidate', ({ candidate, callerId, receiverId }) => {
//       try {
//         if (users[receiverId]) {
//           users[receiverId].forEach((socketId) => {
//             io.to(socketId).emit('iceCandidate', { candidate, callerId });
//           });
//         }
//       } catch (error) {
//         logger.error(`Error in iceCandidate handler: ${error.message}`);
//       }
//     });

//     socket.on('acceptCall', async ({ receiverId, callerId }) => {
//       try {
//         logger.info(`Call accepted: ${receiverId} accepted ${callerId}'s call`);

//         const callerWallet = await Wallet.findOne({ userId: callerId });
//         if (!callerWallet || callerWallet.balance < MINIMUM_BALANCE) {
//           socket.emit('callError', {
//             message: 'Insufficient balance to start call',
//             remainingBalance: callerWallet?.balance || 0
//           });
//           return;
//         }

//         if (users[callerId]) {
//           users[callerId].forEach((socketId) => {
//             io.to(socketId).emit('callAccepted', {
//               receiverId,
//               socketId: socket.id
//             });
//           });

         
//         }
//       } catch (error) {
//         logger.error(`Error in acceptCall handler: ${error.message}`);
//         socket.emit('callError', { message: 'Failed to accept call' });
//       }
//     });

//     socket.on('rejectCall', async ({ receiverId, callerId }) => {
//       try {
//         logger.info(`Call rejected: ${receiverId} rejected ${callerId}'s call`);

//         delete activeCalls[callerId];
//         delete activeCalls[receiverId];

//         if (users[callerId]) {
//           users[callerId].forEach((socketId) => {
//             io.to(socketId).emit('callRejected', { receiverId });
//           });
//         }

//         socket.emit('stopCallerTune', { callerId });

//         await CallLog.create({
//           caller: new mongoose.Types.ObjectId(callerId),
//           receiver: new mongoose.Types.ObjectId(receiverId),
//           startTime: new Date(),
//           endTime: new Date(),
//           duration: 0,
//           status: 'rejected'
//         });
//       } catch (error) {
//         logger.error(`Error in rejectCall handler: ${error.message}`);
//         socket.emit('callError', { message: 'Failed to reject call' });
//       }
//     });

//     socket.on('endCall', async ({ receiverId, callerId }) => {
//       try {
//         logger.info(`Call ended between ${callerId} and ${receiverId}`);

//         if (callTimers[callerId]) {
//           clearInterval(callTimers[callerId]);
//           delete callTimers[callerId];
//         }

//         if (activeCalls[callerId] === receiverId) {
//           if (users[receiverId]) {
//             users[receiverId].forEach((socketId) => {
//               io.to(socketId).emit('callEnded', { callerId });
//             });
//           }

//           delete activeCalls[callerId];
//           delete activeCalls[receiverId];

//           const endTime = new Date();
//           const startTime = new Date(endTime.getTime() - BILLING_INTERVAL); // Use last billing interval
//           const duration = Math.floor((endTime - startTime) / 1000);

//           await CallLog.create({
//             caller: new mongoose.Types.ObjectId(callerId),
//             receiver: new mongoose.Types.ObjectId(receiverId),
//             startTime,
//             endTime,
//             duration,
//             status: 'completed'
//           });
//         }
//       } catch (error) {
//         logger.error(`Error in endCall handler: ${error.message}`);
//       }
//     });

//     // Handle random call request
//     socket.on('requestRandomCall', async ({ userId }) => {
//       try {
//         logger.info(`User ${userId} requesting random call`);

//         // Check caller's balance
//         const callerWallet = await Wallet.findOne({ userId: callerId });
//         if (!callerWallet || callerWallet.balance < MINIMUM_BALANCE) {
//           socket.emit('callError', {
//             message: 'Insufficient balance to start call',
//             remainingBalance: callerWallet?.balance || 0
//           });
//           return;
//         }


//         // Check if user is already in a call
//         if (activeCalls[userId]) {
//           socket.emit('callError', { message: 'You are already in a call' });
//           return;
//         }

//         // Check if user is already in queue
//         if (randomCallQueue.has(userId)) {
//           socket.emit('callError', { message: 'You are already in random call queue' });
//           return;
//         }

//         // Get all available users (excluding the requester and users in calls)
//         const allAvailableUsers = Object.keys(users).filter(potentialUserId =>
//           potentialUserId !== userId && // Not the requesting user
//           !activeCalls[potentialUserId] && // Not in a call
//           users[potentialUserId]?.length > 0 && // Has active socket connections
//           !randomCallQueue.has(potentialUserId) // Not already in queue
//         );

//         logger.info(`Available users for random call with ${userId}:`, {
//           totalAvailable: allAvailableUsers.length,
//           availableUserIds: allAvailableUsers,
//           activeConnections: allAvailableUsers.map(id => ({
//             userId: id,
//             socketCount: users[id]?.length || 0
//           }))
//         });

//         if (allAvailableUsers.length > 0) {
//           // Match with a random available user
//           const randomIndex = Math.floor(Math.random() * allAvailableUsers.length);
//           const matchedUserId = allAvailableUsers[randomIndex];

//           // Get user details for both parties
//           const [caller, receiver] = await Promise.all([
//             User.findById(userId),
//             User.findById(matchedUserId)
//           ]);

//           if (!caller || !receiver) {
//             socket.emit('callError', { message: 'Failed to match users' });
//             return;
//           }

//           // Set active call status
//           activeCalls[userId] = matchedUserId;
//           activeCalls[matchedUserId] = userId;

//           // Notify the caller about the match
//           socket.emit('randomCallMatched', {
//             matchedUserId: matchedUserId,
//             matchedUsername: receiver.username,
//             socketId: socket.id
//           });

//           // Notify the matched user about incoming call
//           users[matchedUserId].forEach((receiverSocketId) => {
//             socket.to(receiverSocketId).emit('incomingRandomCall', {
//               callerId: userId,
//               callerUsername: caller.username,
//               socketId: socket.id
//             });
//           });

//           // Send push notification if receiver has a device token
//           if (receiver.deviceToken) {
//             const title = 'Random Call';
//             const message = `${caller.username} wants to connect with you!`;
//             await sendNotification(receiver.deviceToken, title, message);
//             logger.info(`Push notification sent to User ${matchedUserId}`);
//           }

//           logger.info(`Random call matched: ${userId} with ${matchedUserId}`);

//           // Set a timeout for call acceptance
//           setTimeout(async () => {
//             // If call wasn't accepted/rejected, clean up
//             if (activeCalls[userId] === matchedUserId) {
//               delete activeCalls[userId];
//               delete activeCalls[matchedUserId];

//               socket.emit('callError', { message: 'Call request timed out' });
//               users[matchedUserId]?.forEach((receiverSocketId) => {
//                 socket.to(receiverSocketId).emit('callEnded', { callerId: userId });
//               });

//               logger.info(`Random call timed out between ${userId} and ${matchedUserId}`);
//             }
//           }, 30000); // 30 seconds timeout

//         } else {
//           // Add user to queue if no users available
//           randomCallQueue.add(userId);
//           socket.emit('waitingForRandomMatch', {
//             message: 'Waiting for another user to connect'
//           });
//           logger.info(`User ${userId} added to random call queue`);

//           // Set a timeout for queue waiting
//           setTimeout(() => {
//             if (randomCallQueue.has(userId)) {
//               randomCallQueue.delete(userId);
//               socket.emit('randomCallTimeout', {
//                 message: 'No users available for random call. Please try again later.'
//               });
//               logger.info(`User ${userId} removed from queue due to timeout`);
//             }
//           }, 60000); // 60 seconds queue timeout
//         }
//       } catch (error) {
//         logger.error(`Error in random call handler: ${error.message}`);
//         socket.emit('callError', { message: 'Failed to process random call request' });
//       }
//     });

//     // Handle random call acceptance
//     socket.on('acceptRandomCall', async ({ receiverId, callerId }) => {
//       try {
//         logger.info(`User ${receiverId} accepted random call from User ${callerId}`);

//         if (users[callerId]) {
//           users[callerId].forEach((socketId) => {
//             socket.to(socketId).emit('randomCallAccepted', {
//               receiverId,
//               socketId: socket.id
//             });
//           });
//         }
//       } catch (error) {
//         logger.error(`Error in acceptRandomCall handler: ${error.message}`);
//         socket.emit('callError', { message: 'Failed to accept random call' });
//       }
//     });
//     // Handle random call rejection
//     socket.on('rejectRandomCall', async ({ receiverId, callerId }) => {
//       try {
//         logger.info(`User ${receiverId} rejected random call from User ${callerId}`);

//         // Clean up call status
//         delete activeCalls[callerId];
//         delete activeCalls[receiverId];

//         // Notify caller about rejection
//         if (users[callerId]) {
//           users[callerId].forEach((socketId) => {
//             socket.to(socketId).emit('randomCallRejected', { receiverId });
//           });
//         }

//         // Create call log
//         await CallLog.create({
//           caller: new mongoose.Types.ObjectId(callerId),
//           receiver: new mongoose.Types.ObjectId(receiverId),
//           startTime: new Date(),
//           endTime: new Date(),
//           duration: 0,
//           status: 'rejected',
//           callType: 'random'
//         });
//       } catch (error) {
//         logger.error(`Error in rejectRandomCall handler: ${error.message}`);
//         socket.emit('callError', { message: 'Failed to reject random call' });
//       }
//     });
//     // Cancel random call request
//     socket.on('cancelRandomCall', ({ userId }) => {
//       if (randomCallQueue.has(userId)) {
//         randomCallQueue.delete(userId);
//         socket.emit('randomCallCancelled', {
//           message: 'Random call request cancelled'
//         });
//         logger.info(`User ${userId} cancelled random call request`);
//       }
//     });

//     socket.on('disconnect', () => {
//       logger.info(`Socket disconnected: ${socket.id}`);

//       let disconnectedUserId;
//       for (const [userId, socketIds] of Object.entries(users)) {
//         const index = socketIds.indexOf(socket.id);
//         if (index !== -1) {
//           socketIds.splice(index, 1);
//           disconnectedUserId = userId;

//           if (callTimers[userId]) {
//             clearInterval(callTimers[userId]);
//             delete callTimers[userId];
//           }

//           if (socketIds.length === 0) {
//             delete users[userId];

//             // Clean up random call queue
//             randomCallQueue.delete(userId);
//           }
//           break;
//         }
//       }

//       if (disconnectedUserId && activeCalls[disconnectedUserId]) {
//         const otherUserId = activeCalls[disconnectedUserId];
//         if (users[otherUserId]) {
//           users[otherUserId].forEach((socketId) => {
//             io.to(socketId).emit('callEnded', {
//               callerId: disconnectedUserId,
//               reason: 'User disconnected'
//             });
//           });
//         }

//         delete activeCalls[disconnectedUserId];
//         delete activeCalls[otherUserId];
//       }
//     });

//     // Set up call recording
//     // handleCallRecording(socket);
//   });
// };



import mongoose from 'mongoose';
import CallLog from '../models/Talk-to-friend/callLogModel.js';
import logger from '../logger/winston.logger.js';
import User from '../models/Users.js';
import Wallet from '../models/Wallet/Wallet.js'
import admin from 'firebase-admin';


export const setupWebRTC = (io) => {
  // Store active users and their socket connections
  const users = {}; // { userId: [socketId1, socketId2, ...] }
  const activeCalls = {}; // { userId: otherUserId }
  const callTimings = {};
  const randomCallQueue = new Set();
  const onlineUsers = new Map(); // Map to track user IDs and their socket IDs
  const CALL_TIMEOUT = 60000; // 1 minute in milliseconds

  io.on('connection', (socket) => {
    logger.http(User connected: ${socket.id});


    socket.on('join', async ({ userId }) => {
      try {
        // Ensure user entry in the users object
        if (!users[userId]) {
          users[userId] = [];
        }
        users[userId].push(socket.id);

        // Log socket connection
        logger.info(User ${userId} joined with socket ID ${socket.id});

        // Update user's status in the database
        const updatedUser = await User.findByIdAndUpdate(
          userId,
          { status: 'Online' }, // Assuming status is the field
          { new: true } // Returns the updated document
        );

        if (updatedUser) {
          logger.info(User ${userId}'s status updated to online in the database.);

          // Emit the status update to all connected clients
          io.emit('statusUpdated', { userId, status: 'Online' });
        }
      } catch (error) {
        logger.error(Error updating status for user ${userId}: ${error.message});
      }
    });



    // Listen for statusUpdated event
    socket.on('statusUpdated', (data, callback) => {
      try {
        const { userId, status } = data;

        // Validate the incoming data
        if (!userId || !status) {
          throw new Error('Invalid data: userId and status are required.');
        }

        // Emit the updated status to all connected clients
        io.emit('statusUpdated', { userId, status });

        // Provide a response to the sender (acknowledgment)
        if (callback) {
          callback({ success: true, message: 'Status updated successfully.' });
        }
      } catch (error) {
        console.error('Error handling statusUpdated event:', error.message);

        // Send error response to the sender
        if (callback) {
          callback({ success: false, message: error.message });
        }
      }
    });


    socket.on('requestRandomCall', async ({ userId }) => {
      try {
        logger.info(User ${userId} requesting random call);

        // Check if user is already in a call
        if (activeCalls[userId]) {
          socket.emit('callError', { message: 'You are already in a call' });
          return;
        }

        // Check if user is already in queue
        if (randomCallQueue.has(userId)) {
          socket.emit('callError', { message: 'You are already in random call queue' });
          return;
        }

        const user = await User.findById(userId);

        // Check if user exists and is a CALLER
        if (!user || user.userType !== 'CALLER') {
          socket.emit('callError', { message: 'Only CALLER users can initiate calls' });
          return;
        }

        // Check if user is eligible to initiate a call based on category
        if (['Doctor', 'Therapist', 'Healer', 'Psychologist'].includes(user.userCategory)) {
          socket.emit('callError', { message: 'You are not eligible to initiate a call based on your category' });
          return;
        }

        // Get all available RECEIVER users only
        const allAvailableUsers = Object.keys(users).filter(async potentialUserId => {
          const potentialUser = await User.findById(potentialUserId);
          return potentialUserId !== userId && // Not the requesting user
            !activeCalls[potentialUserId] && // Not in a call
            users[potentialUserId]?.length > 0 && // Has active socket connections
            !randomCallQueue.has(potentialUserId) && // Not already in queue
            potentialUser?.userType === 'RECEIVER'; // Must be a RECEIVER type
        });

        logger.info(Available RECEIVER users for call with ${userId}:, {
          totalAvailable: allAvailableUsers.length,
          availableUserIds: allAvailableUsers,
          activeConnections: allAvailableUsers.map(id => ({
            userId: id,
            socketCount: users[id]?.length || 0
          }))
        });

        if (allAvailableUsers.length > 0) {
          // Match with a random available RECEIVER user
          const randomIndex = Math.floor(Math.random() * allAvailableUsers.length);
          const matchedUserId = allAvailableUsers[randomIndex];

          // Get user details for both parties
          const [caller, receiver] = await Promise.all([
            User.findById(userId),
            User.findById(matchedUserId)
          ]);

          if (!caller || !receiver) {
            socket.emit('callError', { message: 'Failed to match users' });
            return;
          }

          // Verify again that receiver is of type RECEIVER
          if (receiver.userType !== 'RECEIVER') {
            socket.emit('callError', { message: 'Invalid match - Receiver type mismatch' });
            return;
          }

          // Set active call status
          activeCalls[userId] = matchedUserId;
          activeCalls[matchedUserId] = userId;

          // Notify the caller about the match
          socket.emit('randomCallMatched', {
            matchedUserId: matchedUserId,
            matchedUsername: receiver.username,
            socketId: socket.id
          });

          // Notify the matched RECEIVER about incoming call
          users[matchedUserId].forEach((receiverSocketId) => {
            socket.to(receiverSocketId).emit('incomingRandomCall', {
              callerId: userId,
              callerUsername: caller.username,
              socketId: socket.id
            });
          });

          // Send push notification if receiver has a device token
          if (receiver.deviceToken) {
            const title = 'Incoming Call';
            const message = ${caller.username} wants to connect with you!;
            await sendNotification(matchedUserId, title, message);
            logger.info(Push notification sent to RECEIVER ${matchedUserId});
          }

          logger.info(Call matched: CALLER ${userId} with RECEIVER ${matchedUserId});

        } else {
          // Add CALLER to queue if no RECEIVER users available
          randomCallQueue.add(userId);
          socket.emit('waitingForRandomMatch', {
            message: 'Waiting for a RECEIVER to become available'
          });
          logger.info(CALLER ${userId} added to call queue);

          // Set a timeout for queue waiting
          setTimeout(() => {
            if (randomCallQueue.has(userId)) {
              randomCallQueue.delete(userId);
              socket.emit('randomCallTimeout', {
                message: 'No RECEIVER users available. Please try again later.'
              });
              logger.info(CALLER ${userId} removed from queue due to timeout);
            }
          }, 60000); // 60 seconds queue timeout
        }
      } catch (error) {
        logger.error(Error in call handler: ${error.message});
        socket.emit('callError', { message: 'Failed to process call request' });
      }
    });

    // Add a middleware to prevent CALLER users from receiving calls
    socket.use((packet, next) => {
      const eventName = packet[0];
      if (eventName === 'incomingRandomCall') {
        const userId = socket.userId; // Assuming you store userId in socket
        User.findById(userId)
          .then(user => {
            if (user && user.userType === 'CALLER') {
              // Block the incoming call event for CALLER users
              return;
            }
            next();
          })
          .catch(error => {
            logger.error(Error in socket middleware: ${error.message});
            next();
          });
      } else {
        next();
      }
    });



    socket.on('acceptRandomCall', async ({ receiverId, callerId }) => {
      try {
        logger.info(User ${receiverId} accepted random call from User ${callerId});

        // Store call start time
        const callKey = ${receiverId}_${callerId};

        callTimings[callKey] = {
          startTime: new Date()
        };



        if (users[callerId]) {
          users[callerId].forEach((socketId) => {
            socket.to(socketId).emit('randomCallAccepted', {
              receiverId,
              socketId: socket.id
            });
          });
        }
      } catch (error) {
        logger.error(Error in acceptRandomCall handler: ${error.message});
        socket.emit('callError', { message: 'Failed to accept random call' });
      }
    });

    // Handle random call rejection
    socket.on('rejectRandomCall', async ({ receiverId, callerId }) => {
      try {
        logger.info(User ${receiverId} rejected random call from User ${callerId});

        // Clean up call status
        delete activeCalls[callerId];
        delete activeCalls[receiverId];

        // Notify caller about rejection
        if (users[callerId]) {
          users[callerId].forEach((socketId) => {
            socket.to(socketId).emit('randomCallRejected', { receiverId });
          });
        }

        // Create call log
        await CallLog.create({
          caller: new mongoose.Types.ObjectId(callerId),
          receiver: new mongoose.Types.ObjectId(receiverId),
          startTime: new Date(),
          endTime: new Date(),
          duration: 0,
          status: 'rejected',
          callType: 'random'
        });
      } catch (error) {
        logger.error(Error in rejectRandomCall handler: ${error.message});
        socket.emit('callError', { message: 'Failed to reject random call' });
      }
    });

    // Cancel random call request
    socket.on('cancelRandomCall', ({ userId }) => {
      if (randomCallQueue.has(userId)) {
        randomCallQueue.delete(userId);
        socket.emit('randomCallCancelled', {
          message: 'Random call request cancelled'
        });
        logger.info(User ${userId} cancelled random call request);
      }
    });

    // Initial call request

    socket.on('call', async ({ callerId, receiverId }) => {
      try {
        logger.info(User ${callerId} is calling User ${receiverId});

        // Check if either user is already in a call
        if (activeCalls[receiverId] || activeCalls[callerId]) {
          socket.emit('userBusy', { receiverId });
          logger.warn(User ${receiverId} or ${callerId} is already in a call);
          return;
        }

        // Fetch user details
        const [receiver, caller] = await Promise.all([
          User.findById(receiverId),
          User.findById(callerId),
        ]);

        if (!receiver) {
          socket.emit('receiverUnavailable', { receiverId });
          logger.warn(User ${receiverId} not found);
          return;
        }

        if (!caller) {
          socket.emit('callerUnavailable', { callerId });
          logger.warn(User ${callerId} not found);
          return;
        }

        // Initialize socket arrays if needed
        if (!users[callerId]) users[callerId] = [];
        if (!users[receiverId]) users[receiverId] = [];

        // Add current socket to caller's sockets if not already present
        if (!users[callerId].includes(socket.id)) {
          users[callerId].push(socket.id);
        }

        if (users[receiverId].length > 0) {
          // Notify all receiver's sockets about the incoming call
          users[receiverId].forEach((socketId) => {
            socket.to(socketId).emit('incomingCall', {
              callerId,
              callerSocketId: socket.id, // Provide caller's socket ID
            });
          });

          // Notify the caller to play caller tune
          socket.emit('playCallerTune', { callerId });

          // Send push notification if the receiver has a device token
          if (receiver.deviceToken) {
            const title = 'Incoming Call';
            const message = ${caller.username} is calling you!;
            const type = 'incoming_Call';
            const senderName = caller.username || 'Unknown Caller';
            const senderAvatar = caller.avatarUrl || 'https://investogram.ukvalley.com/avatars/default.png';

            await sendNotification(receiverId, title, message, type, callerId, senderName, senderAvatar);
            logger.info(Push notification sent to User ${receiverId});
          }
        } else {
          if (receiver.deviceToken) {
            const title = 'Incoming Call';
            const message = ${caller.username || 'Unknown Caller'} is calling you!;
            const type = 'incoming_Call';
            const senderName = caller.username || 'Unknown Caller';
            const senderAvatar = caller.avatarUrl || 'https://investogram.ukvalley.com/avatars/default.png';

            try {
              // Initial notification
              await sendNotification(receiverId, title, message, type, callerId, senderName, senderAvatar);
              logger.info(Push notification sent to User ${receiverId});

              // Retry after 30 seconds if still not connected
              const callTimeout = setTimeout(async () => {
                try {
                  await sendNotification(receiverId, title, message, type, callerId, senderName, senderAvatar);
                  logger.info(Retry push notification sent to User ${receiverId});
                } catch (retryError) {
                  logger.error(Retry push notification failed for User ${receiverId}: ${retryError.message});
                }
              }, 30000); // 30 seconds

              // Cleanup timeout if the call is accepted or rejected
              socket.on('acceptCall', () => {
                clearTimeout(callTimeout);
                logger.info(Call accepted by User ${receiverId});
              });

              socket.on('rejectCall', () => {
                clearTimeout(callTimeout);
                logger.info(Call rejected by User ${receiverId});
              });

              socket.on('endCall', () => {
                clearTimeout(callTimeout);
                logger.info(Call ended by User ${receiverId});
              });

            } catch (error) {
              logger.error(Failed to send push notification to User ${receiverId}: ${error.message});
            }
          } else {
            logger.warn(No device token available for User ${receiverId}, skipping notification);
          }
        }

      } catch (error) {
        logger.error(Error in call handler: ${error.message});
        socket.emit('callError', { message: 'Failed to initiate call' });
      }
    });

    

    // Handle WebRTC offer
    socket.on('offer', async ({ offer, callerId, receiverId }) => {
      try {
        logger.info(User ${callerId} sending offer to User ${receiverId});

        // Set active call status during WebRTC setup
        activeCalls[callerId] = receiverId;
        activeCalls[receiverId] = callerId;

        if (users[receiverId]) {
          users[receiverId].forEach((socketId) => {
            socket.to(socketId).emit('offer', { offer, callerId });
          });
          logger.info(Offer sent to User ${receiverId});
        } else {
          socket.emit('userUnavailable', { receiverId });
          logger.warn(User ${receiverId} not found during offer);
        }
      } catch (error) {
        logger.error(Error in offer handler: ${error.message});
        socket.emit('callError', { message: 'Failed to process offer' });
      }
    });

    // Handle WebRTC answer
    socket.on('answer', ({ answer, receiverId, callerId }) => {
      try {
        logger.info(User ${receiverId} sending answer to User ${callerId});

        if (users[callerId]) {
          users[callerId].forEach((socketId) => {
            socket.to(socketId).emit('answer', { answer, receiverId });
          });
        }
      } catch (error) {
        logger.error(Error in answer handler: ${error.message});
        socket.emit('callError', { message: 'Failed to process answer' });
      }
    });

    // Handle ICE candidates
    socket.on('iceCandidate', ({ candidate, callerId, receiverId }) => {
      try {
        if (users[receiverId]) {
          users[receiverId].forEach((socketId) => {
            socket.to(socketId).emit('iceCandidate', { candidate, callerId });
          });
        }
      } catch (error) {
        logger.error(Error in iceCandidate handler: ${error.message});
      }
    });


    // socket.on('acceptCall', async ({ receiverId, callerId }) => {
    //   try {
    //     logger.info(User ${receiverId} accepted call from User ${callerId});

    //     // Store start time as a Date object
    //     const callKey = ${receiverId}_${callerId};
    //     logger.info(callKey ${callKey});

    //     callTimings[callKey] = {
    //       startTime: new Date() // Start time as a Date object
    //     };

    //     // Notify the caller that the call has been accepted
    //     if (users[callerId]) {
    //       users[callerId].forEach((socketId) => {
    //         socket.to(socketId).emit('callAccepted', {
    //           receiverId,
    //           socketId: socket.id
    //         });
    //         socket.to(socketId).emit('activeCall',{
    //           callerId,
    //           receiverId,
    //           socketId:socket.id
    //         }
    //       });

    //       // Stop the caller's tune after call acceptance
    //       socket.emit('stopCallerTune', { callerId });
    //     }
    //   } catch (error) {
    //     logger.error(Error in acceptCall handler: ${error.message});
    //     socket.emit('callError', { message: 'Failed to accept call' });
    //   }
    // });

    socket.on('acceptCall', async ({ receiverId, callerId }) => {
      try {
        logger.info(User ${receiverId} accepted the call from User ${callerId});
    
        // Generate a unique key for the call session
        const callKey = ${receiverId}_${callerId};
        logger.info(Call session key: ${callKey});
    
        // Record the start time of the call
        callTimings[callKey] = {
          startTime: new Date(), // Start time as a Date object
        };
    
        // Notify the caller that the call has been accepted
        if (users[callerId] && users[callerId].length > 0) {
          users[callerId].forEach((socketId) => {
            // Emit 'callAccepted' to all the caller's connected sockets
            socket.to(socketId).emit('callAccepted', {
              receiverId,
              receiverSocketId: socket.id, // Provide the receiver's socket ID
            });
    
            // Notify about the active call
            socket.to(socketId).emit('activeCall', {
              callerId,
              receiverId,
              receiverSocketId: socket.id,
            });
          });
    
          logger.info(Call accepted notification sent to User ${callerId});
    
          // Stop the caller's tune after call acceptance
          socket.emit('stopCallerTune', { callerId });
        } else {
          // Handle the case where the caller's socket information is missing
          logger.warn(Caller sockets not found for User ${callerId});
          socket.emit('callError', {
            message: Unable to notify User ${callerId} about call acceptance.,
          });
        }
    
        // Log successful acceptance
        logger.info(
          Call between User ${callerId} and User ${receiverId} is now active.
        );
    
      } catch (error) {
        // Handle errors gracefully
        logger.error(Error in acceptCall handler: ${error.message});
        socket.emit('callError', {
          message: 'An error occurred while accepting the call. Please try again.',
        });
      }
    });
    

    





    // Handle call rejection
    socket.on('rejectCall', async ({ receiverId, callerId }) => {
      try {
        logger.info(User ${receiverId} rejected call from User ${callerId});

        // Clean up call status
        delete activeCalls[callerId];
        delete activeCalls[receiverId];

        // Notify caller about rejection
        if (users[callerId]) {
          users[callerId].forEach((socketId) => {
            socket.to(socketId).emit('callRejected', { receiverId });
          });
        }

        // Stop caller tune
        socket.emit('stopCallerTune', { callerId });

        // Create call log
        await CallLog.create({
          caller: new mongoose.Types.ObjectId(callerId),
          receiver: new mongoose.Types.ObjectId(receiverId),
          startTime: new Date(),
          endTime: new Date(),
          duration: 0,
          status: 'rejected'
        });
      } catch (error) {
        logger.error(Error in rejectCall handler: ${error.message});
        socket.emit('callError', { message: 'Failed to reject call' });
      }
    });



    socket.on('endCall', async ({ receiverId, callerId }) => {
      try {
        logger.info(Call ended between ${callerId} and ${receiverId});

        if (activeCalls[callerId] === receiverId) {
          // Notify the other party
          if (users[receiverId]) {
            users[receiverId].forEach((socketId) => {
              socket.to(socketId).emit('callEnded', { callerId });
            });
          }

          // Calculate call duration
          const callerCallKey = ${callerId}_${receiverId};
          const receiverCallKey = ${receiverId}_${callerId};
          const startTime = callTimings[callerCallKey]?.startTime || callTimings[receiverCallKey]?.startTime;
          const endTime = new Date();
          const duration = (endTime - startTime) / 1000; // Calculate duration in seconds

          // Log the call with duration
          await CallLog.create({
            caller: new mongoose.Types.ObjectId(callerId),
            receiver: new mongoose.Types.ObjectId(receiverId),
            startTime,
            endTime,
            duration,
            status: 'completed'
          });

          // Clean up call status
          delete activeCalls[callerId];
          delete activeCalls[receiverId];
          delete callTimings[callerCallKey]?.startTime || callTimings[receiverCallKey]?.startTime;
        }
      } catch (error) {
        logger.error(Error in endCall handler: ${error.message});
      }
    });

    // Update disconnect handler to handle call timings cleanup

    // socket.on('disconnect', async () => {
    //   logger.info(Socket disconnected: ${socket.id});

    //   // Find and remove the disconnected socket
    //   let disconnectedUserId;
    //   for (const [userId, socketIds] of Object.entries(users)) {
    //     const index = socketIds.indexOf(socket.id);
    //     if (index !== -1) {
    //       socketIds.splice(index, 1);
    //       disconnectedUserId = userId;

    //       // Remove user entry if no sockets left
    //       if (socketIds.length === 0) {
    //         delete users[userId];

    //         // Update user status to offline in database
    //         try {
    //           await User.findByIdAndUpdate(
    //             disconnectedUserId,
    //             {
    //               status: 'offline',
    //             }
    //           );

    //           // Broadcast offline status to other users
    //           socket.broadcast.emit('userStatusChanged', {
    //             userId: disconnectedUserId,
    //             status: 'offline'
    //           });
    //         } catch (error) {
    //           logger.error(Error updating user offline status: ${error.message});
    //         }
    //       }
    //       break;
    //     }
    //   }

    //   // End any active calls for the disconnected user
    //   if (disconnectedUserId && activeCalls[disconnectedUserId]) {
    //     const otherUserId = activeCalls[disconnectedUserId];

    //     // Log call if it was ongoing
    //     const callKey = ${disconnectedUserId}_${otherUserId};
    //     const reverseCallKey = ${otherUserId}_${disconnectedUserId};

    //     if (callTimings[callKey] || callTimings[reverseCallKey]) {
    //       const endTime = new Date();
    //       const startTime = callTimings[callKey]?.startTime || callTimings[reverseCallKey]?.startTime;
    //       const duration = Math.floor((endTime - startTime) / 1000);

    //       // Create call log for disconnected call
    //       CallLog.create({
    //         caller: new mongoose.Types.ObjectId(disconnectedUserId),
    //         receiver: new mongoose.Types.ObjectId(otherUserId),
    //         startTime,
    //         endTime,
    //         duration,
    //         status: 'disconnected'
    //       }).catch(error => {
    //         logger.error(Error logging disconnected call: ${error.message});
    //       });

    //       // Clean up call timings
    //       delete callTimings[callKey];
    //       delete callTimings[reverseCallKey];
    //     }

    //     // Notify other user about call end
    //     if (users[otherUserId]) {
    //       users[otherUserId].forEach((socketId) => {
    //         socket.to(socketId).emit('callEnded', {
    //           callerId: disconnectedUserId
    //         });
    //       });
    //     }

    //     delete activeCalls[disconnectedUserId];
    //     delete activeCalls[otherUserId];
    //   }
    // });








// import mongoose from 'mongoose';
// import CallLog from '../models/Talk-to-friend/callLogModel.js';
// import logger from '../logger/winston.logger.js';
// import User from '../models/Users.js';
// import Wallet from '../models/Wallet/Wallet.js'
// import admin from 'firebase-admin';
// // import { ChatMessage } from '../models/message.models.js';

// export const setupWebRTC = (io) => {
//   // Store active users and their socket connections
//   const users = {}; // { userId: [socketId1, socketId2, ...] }
//   const activeCalls = {}; // { userId: otherUserId }
//   const callTimings = {};
//   const randomCallQueue = new Set();
//   const iceTimeouts = {};
//   const iceStates = {};
//   const callStates = {};
//   const onlineUsers = new Map();
//   const CALL_TIMEOUT = 60000;
//   // Queue to store connected users
//   const userQueue = [];

//   // Function to add user to the queue
//   const addUserToQueue = (userId, socketId) => {
//     userQueue.push({ userId, socketId });
//   };

//   // Function to remove user from the queue
//   const removeUserFromQueue = (socketId) => {
//     const index = userQueue.findIndex(user => user.socketId === socketId);
//     if (index !== -1) userQueue.splice(index, 1);
//   };


//   io.on('connection', (socket) => {
//     logger.http(`User connected: ${socket.id}`);


//     socket.on('join', async ({ userId }) => {
//       try {
//         // Ensure user entry in the users object
//         if (!users[userId]) {
//           users[userId] = [];
//         }
//         users[userId].push(socket.id);

//         // Log socket connection
//         logger.info(`User ${userId} joined with socket ID ${socket.id}`);

//         // Update user's status in the database
//         const updatedUser = await User.findByIdAndUpdate(
//           userId,
//           { status: 'Online' }, // Assuming `status` is the field
//           { new: true } // Returns the updated document
//         );

//         if (updatedUser) {
//           logger.info(`User ${userId}'s status updated to online in the database.`);

//           // Emit the status update to all connected clients
//           io.emit('statusUpdated', { userId, status: 'Online' });
//         }
//       } catch (error) {
//         logger.error(`Error updating status for user ${userId}: ${error.message}`);
//       }
//     });



//     // Listen for `statusUpdated` event
//     socket.on('statusUpdated', ({ userId, status }) => {
//       try {

//         // Validate the incoming data
//         if (!userId || !status) {
//           throw new Error('Invalid data: userId and status are required.');
//         }

//         // Emit the updated status to all connected clients
//         io.emit('statusUpdated', { userId, status });

//         // Provide a response to the sender (acknowledgment)

//       } catch (error) {
//         console.error('Error handling statusUpdated event:', error.message);


//       }
//     });

//     socket.on('registerUser', async (userId) => {
//       addUserToQueue(userId, socket.id);
//       console.log(`User registered: ${userId}`);
//       console.log('Current queue:', userQueue);
//       const updatedUser = await User.findByIdAndUpdate(
//         userId,
//         { status: 'Online' }, // Assuming `status` is the field
//         { new: true } // Returns the updated document
//       );
//       if (updatedUser) {

//         io.emit('updateQueue', userQueue);
//       }

//       // Emit the current queue to all connected clients
//     });

//     socket.on('requestRandomCall', async ({ userId }) => {
//       try {
//         logger.info(`User ${userId} requesting random call`);

//         // Check if user is already in a call
//         if (activeCalls[userId]) {
//           socket.emit('callError', { message: 'You are already in a call' });
//           return;
//         }

//         // Check if user is already in queue
//         if (randomCallQueue.has(userId)) {
//           socket.emit('callError', { message: 'You are already in random call queue' });
//           return;
//         }

//         const user = await User.findById(userId);

//         // Check if user exists and is a CALLER
//         if (!user || user.userType !== 'CALLER') {
//           socket.emit('callError', { message: 'Only CALLER users can initiate calls' });
//           return;
//         }

//         // Check if user is eligible to initiate a call based on category
//         if (['Doctor', 'Therapist', 'Healer', 'Psychologist'].includes(user.userCategory)) {
//           socket.emit('callError', { message: 'You are not eligible to initiate a call based on your category' });
//           return;
//         }

//         // Get all available RECEIVER users only
//         const allAvailableUsers = Object.keys(users).filter(async potentialUserId => {
//           const potentialUser = await User.findById(potentialUserId);
//           return potentialUserId !== userId && // Not the requesting user
//             !activeCalls[potentialUserId] && // Not in a call
//             users[potentialUserId]?.length > 0 && // Has active socket connections
//             !randomCallQueue.has(potentialUserId) && // Not already in queue
//             potentialUser?.userType === 'RECEIVER'; // Must be a RECEIVER type
//         });

//         logger.info(`Available RECEIVER users for call with ${userId}:`, {
//           totalAvailable: allAvailableUsers.length,
//           availableUserIds: allAvailableUsers,
//           activeConnections: allAvailableUsers.map(id => ({
//             userId: id,
//             socketCount: users[id]?.length || 0
//           }))
//         });

//         if (allAvailableUsers.length > 0) {
//           // Match with a random available RECEIVER user
//           const randomIndex = Math.floor(Math.random() * allAvailableUsers.length);
//           const matchedUserId = allAvailableUsers[randomIndex];

//           // Get user details for both parties
//           const [caller, receiver] = await Promise.all([
//             User.findById(userId),
//             User.findById(matchedUserId)
//           ]);

//           if (!caller || !receiver) {
//             socket.emit('callError', { message: 'Failed to match users' });
//             return;
//           }

//           // Verify again that receiver is of type RECEIVER
//           if (receiver.userType !== 'RECEIVER') {
//             socket.emit('callError', { message: 'Invalid match - Receiver type mismatch' });
//             return;
//           }

//           // Set active call status
//           activeCalls[userId] = matchedUserId;
//           activeCalls[matchedUserId] = userId;

//           // Notify the caller about the match
//           socket.emit('randomCallMatched', {
//             matchedUserId: matchedUserId,
//             matchedUsername: receiver.username,
//             socketId: socket.id
//           });

//           // Notify the matched RECEIVER about incoming call
//           users[matchedUserId].forEach((receiverSocketId) => {
//             socket.to(receiverSocketId).emit('incomingRandomCall', {
//               callerId: userId,
//               callerUsername: caller.username,
//               socketId: socket.id
//             });
//           });

//           // Send push notification if receiver has a device token
//           if (receiver.deviceToken) {
//             const title = 'Incoming Call';
//             const message = `${caller.username} wants to connect with you!`;
//             await sendNotification(matchedUserId, title, message);
//             logger.info(`Push notification sent to RECEIVER ${matchedUserId}`);
//           }

//           logger.info(`Call matched: CALLER ${userId} with RECEIVER ${matchedUserId}`);

//         } else {
//           // Add CALLER to queue if no RECEIVER users available
//           randomCallQueue.add(userId);
//           socket.emit('waitingForRandomMatch', {
//             message: 'Waiting for a RECEIVER to become available'
//           });
//           logger.info(`CALLER ${userId} added to call queue`);

//           // Set a timeout for queue waiting
//           setTimeout(() => {
//             if (randomCallQueue.has(userId)) {
//               randomCallQueue.delete(userId);
//               socket.emit('randomCallTimeout', {
//                 message: 'No RECEIVER users available. Please try again later.'
//               });
//               logger.info(`CALLER ${userId} removed from queue due to timeout`);
//             }
//           }, 60000); // 60 seconds queue timeout
//         }
//       } catch (error) {
//         logger.error(`Error in call handler: ${error.message}`);
//         socket.emit('callError', { message: 'Failed to process call request' });
//       }
//     });

//     // Add a middleware to prevent CALLER users from receiving calls
//     socket.use((packet, next) => {
//       const eventName = packet[0];
//       if (eventName === 'incomingRandomCall') {
//         const userId = socket.userId; // Assuming you store userId in socket
//         User.findById(userId)
//           .then(user => {
//             if (user && user.userType === 'CALLER') {
//               // Block the incoming call event for CALLER users
//               return;
//             }
//             next();
//           })
//           .catch(error => {
//             logger.error(`Error in socket middleware: ${error.message}`);
//             next();
//           });
//       } else {
//         next();
//       }
//     });



//     socket.on('acceptRandomCall', async ({ receiverId, callerId }) => {
//       try {
//         logger.info(`User ${receiverId} accepted random call from User ${callerId}`);

//         // Store call start time
//         const callKey = `${receiverId}_${callerId}`;

//         callTimings[callKey] = {
//           startTime: new Date()
//         };



//         if (users[callerId]) {
//           users[callerId].forEach((socketId) => {
//             socket.to(socketId).emit('randomCallAccepted', {
//               receiverId,
//               socketId: socket.id
//             });
//           });
//         }
//       } catch (error) {
//         logger.error(`Error in acceptRandomCall handler: ${error.message}`);
//         socket.emit('callError', { message: 'Failed to accept random call' });
//       }
//     });

//     // Handle random call rejection
//     socket.on('rejectRandomCall', async ({ receiverId, callerId }) => {
//       try {
//         logger.info(`User ${receiverId} rejected random call from User ${callerId}`);

//         // Clean up call status
//         delete activeCalls[callerId];
//         delete activeCalls[receiverId];

//         // Notify caller about rejection
//         if (users[callerId]) {
//           users[callerId].forEach((socketId) => {
//             socket.to(socketId).emit('randomCallRejected', { receiverId });
//           });
//         }

//         // Create call log
//         await CallLog.create({
//           caller: new mongoose.Types.ObjectId(callerId),
//           receiver: new mongoose.Types.ObjectId(receiverId),
//           startTime: new Date(),
//           endTime: new Date(),
//           duration: 0,
//           status: 'rejected',
//           callType: 'random'
//         });
//       } catch (error) {
//         logger.error(`Error in rejectRandomCall handler: ${error.message}`);
//         socket.emit('callError', { message: 'Failed to reject random call' });
//       }
//     });

//     // Cancel random call request
//     socket.on('cancelRandomCall', ({ userId }) => {
//       if (randomCallQueue.has(userId)) {
//         randomCallQueue.delete(userId);
//         socket.emit('randomCallCancelled', {
//           message: 'Random call request cancelled'
//         });
//         logger.info(`User ${userId} cancelled random call request`);
//       }
//     });

//     // Initial call request

//     // socket.on('call', async ({ callerId, receiverId }) => {
//     //   try {
//     //     logger.info(`User ${callerId} is calling User ${receiverId}`);

//     //     // Check if either user is already in a call
//     //     if (activeCalls[receiverId] || activeCalls[callerId]) {
//     //       socket.emit('userBusy', { receiverId });
//     //       logger.warn(`User ${receiverId} or ${callerId} is already in a call`);
//     //       return;
//     //     }

//     //     // Fetch user details
//     //     const [receiver, caller] = await Promise.all([
//     //       User.findById(receiverId),
//     //       User.findById(callerId),
//     //     ]);

//     //     if (!receiver) {
//     //       socket.emit('receiverUnavailable', { receiverId });
//     //       logger.warn(`User ${receiverId} not found`);
//     //       return;
//     //     }

//     //     if (!caller) {
//     //       socket.emit('callerUnavailable', { callerId });
//     //       logger.warn(`User ${callerId} not found`);
//     //       return;
//     //     }

//     //     // Initialize socket arrays if needed
//     //     if (!users[callerId]) users[callerId] = [];
//     //     if (!users[receiverId]) users[receiverId] = [];

//     //     // Add current socket to caller's sockets if not already present
//     //     if (!users[callerId].includes(socket.id)) {
//     //       users[callerId].push(socket.id);
//     //     }

//     //     if (users[receiverId].length > 0) {
//     //       // Notify all receiver's sockets about the incoming call
//     //       users[receiverId].forEach((socketId) => {
//     //         socket.to(socketId).emit('incomingCall', {
//     //           callerId,
//     //           callerSocketId: socket.id, // Provide caller's socket ID
//     //         });
//     //       });

//     //       // Notify the caller to play caller tune
//     //       socket.emit('playCallerTune', { callerId });

//     //       // Send push notification if the receiver has a device token
//     //       if (receiver.deviceToken) {
//     //         const title = 'Incoming Call';
//     //         const message = `${caller.username} is calling you!`;
//     //         const type = 'incoming_Call';
//     //         const senderName = caller.username || 'Unknown Caller';
//     //         const senderAvatar = caller.avatarUrl || 'https://investogram.ukvalley.com/avatars/default.png';

//     //         await sendNotification(receiverId, title, message, type, callerId, senderName, senderAvatar);
//     //         logger.info(`Push notification sent to User ${receiverId}`);
//     //       }
//     //     } else {
//     //       if (receiver.deviceToken) {
//     //         const title = 'Incoming Call';
//     //         const message = `${caller.username || 'Unknown Caller'} is calling you!`;
//     //         const type = 'incoming_Call';
//     //         const senderName = caller.username || 'Unknown Caller';
//     //         const senderAvatar = caller.avatarUrl || 'https://investogram.ukvalley.com/avatars/default.png';

//     //         try {
//     //           // Initial notification
//     //           await sendNotification(receiverId, title, message, type, callerId, senderName, senderAvatar);
//     //           logger.info(`Push notification sent to User ${receiverId}`);

//     //           // Retry after 30 seconds if still not connected
//     //           const callTimeout = setTimeout(async () => {
//     //             try {
//     //               await sendNotification(receiverId, title, message, type, callerId, senderName, senderAvatar);
//     //               logger.info(`Retry push notification sent to User ${receiverId}`);
//     //             } catch (retryError) {
//     //               logger.error(`Retry push notification failed for User ${receiverId}: ${retryError.message}`);
//     //             }
//     //           }, 30000); // 30 seconds

//     //           // Cleanup timeout if the call is accepted or rejected
//     //           socket.on('acceptCall', () => {
//     //             clearTimeout(callTimeout);
//     //             logger.info(`Call accepted by User ${receiverId}`);
//     //           });

//     //           socket.on('rejectCall', () => {
//     //             clearTimeout(callTimeout);
//     //             logger.info(`Call rejected by User ${receiverId}`);
//     //           });

//     //           socket.on('endCall', () => {
//     //             clearTimeout(callTimeout);
//     //             logger.info(`Call ended by User ${receiverId}`);
//     //           });

//     //         } catch (error) {
//     //           logger.error(`Failed to send push notification to User ${receiverId}: ${error.message}`);
//     //         }
//     //       } else {
//     //         logger.warn(`No device token available for User ${receiverId}, skipping notification`);
//     //       }
//     //     }

//     //   } catch (error) {
//     //     logger.error(`Error in call handler: ${error.message}`);
//     //     socket.emit('callError', { message: 'Failed to initiate call' });
//     //   }
//     // });


//     socket.on('call', async ({ callerId, receiverId }) => {
//       // Initialize call state tracking
//       const callLockKey = `${callerId}_${receiverId}`;

//       try {
//         logger.info(`User ${callerId} is initiating call to User ${receiverId}`);

//         // Prevent duplicate call attempts
//         if (callLocks[callLockKey]) {
//           socket.emit('callError', { message: 'Call setup already in progress' });
//           logger.warn(`Duplicate call attempt from ${callerId} to ${receiverId}`);
//           return;
//         }
//         callLocks[callLockKey] = true;

//         // Set call timeout
//         const callSetupTimeout = setTimeout(() => {
//           if (!activeCalls[callerId]) {
//             socket.emit('callTimeout', { receiverId });
//             cleanupCallState(callerId, receiverId);
//             logger.warn(`Call setup timeout for call from ${callerId} to ${receiverId}`);
//           }
//         }, 30000); // 30 second timeout

//         // Check if either user is in a call
//         if (activeCalls[receiverId] || activeCalls[callerId]) {
//           socket.emit('userBusy', {
//             receiverId,
//             message: `User is currently in another call`
//           });
//           logger.warn(`Call blocked - User ${receiverId} or ${callerId} is in active call`);
//           cleanupCallState(callerId, receiverId);
//           return;
//         }

//         // Verify user online status
//         const [receiver, caller] = await Promise.all([
//           User.findById(receiverId).select('deviceToken username avatarUrl status lastSeen'),
//           User.findById(callerId).select('username avatarUrl'),
//         ]);

//         if (!receiver || !caller) {
//           const missingUser = !receiver ? 'receiver' : 'caller';
//           const userId = !receiver ? receiverId : callerId;
//           socket.emit(`${missingUser}Unavailable`, {
//             [`${missingUser}Id`]: userId,
//             message: `User not found`
//           });
//           logger.warn(`${missingUser} user ${userId} not found`);
//           cleanupCallState(callerId, receiverId);
//           return;
//         }

//         // Initialize and manage socket arrays
//         users[callerId] = users[callerId] || new Set();
//         users[receiverId] = users[receiverId] || new Set();
//         users[callerId].add(socket.id);

//         // Track call attempt

//         // Handle receiver notification
//         if (users[receiverId].size > 0) {
//           await handleOnlineReceiverCall(socket, callerId, receiverId, caller, receiver);
//         } else {
//           await handleOfflineReceiverCall(socket, callerId, receiverId, caller, receiver);
//         }

//         // Clear timeout on call acceptance or rejection
//         socket.once('acceptCall', () => {
//           clearTimeout(callSetupTimeout);
//           delete callLocks[callLockKey];
//         });

//         socket.once('rejectCall', () => {
//           clearTimeout(callSetupTimeout);
//           cleanupCallState(callerId, receiverId);
//         });

//       } catch (error) {
//         logger.error(`Error in call handler: ${error.message}`);
//         socket.emit('callError', {
//           message: 'Failed to initiate call. Please try again.',
//           error: error.message
//         });
//         cleanupCallState(callerId, receiverId);
//       }
//     });

//     // Helper function to handle online receiver call
//     async function handleOnlineReceiverCall(socket, callerId, receiverId, caller, receiver) {
//       // Notify all receiver's sockets
//       Array.from(users[receiverId]).forEach((socketId) => {
//         socket.to(socketId).emit('incomingCall', {
//           callerId,
//           callerSocketId: socket.id,
//           callerName: caller.username || 'Unknown Caller',
//           callerAvatar: caller.avatarUrl
//         });
//       });

//       // Start caller tune
//       socket.emit('playCallerTune', {
//         callerId,
//         receiverName: receiver.username
//       });

//       // Send push notification if device token exists
//       if (receiver.deviceToken) {
//         const title = 'Incoming Call';
//         const message = `${caller.username || 'Unknown Caller'} is calling you!`;
//         const type = 'incoming_Call';
//         const senderName = caller.username || 'Unknown Caller';
//         const senderAvatar = caller.avatarUrl || 'https://investogram.ukvalley.com/avatars/default.png';

//         await sendNotification_call(receiverId, title, message, type, callerId, senderName, senderAvatar);
//         logger.info(`Push notification sent to User ${receiverId}`);
//       }

//       logger.info(`Call notification sent to online user ${receiverId}`);
//     }

//     // Helper function to handle offline receiver call
//     async function handleOfflineReceiverCall(socket, callerId, receiverId, caller, receiver) {
//       if (!receiver.deviceToken) {
//         socket.emit('receiverOffline', {
//           receiverId,
//           message: 'User is offline and has no notification token'
//         });
//         logger.warn(`No device token for offline user ${receiverId}`);
//         return;
//       }

//       try {
//         if (receiver.deviceToken) {
//           const title = 'Incoming Call';
//           const message = `${caller.username || 'Unknown Caller'} is calling you!`;
//           const type = 'incoming_Call';
//           const senderName = caller.username || 'Unknown Caller';
//           const senderAvatar = caller.avatarUrl || 'https://investogram.ukvalley.com/avatars/default.png';
  
//           await sendNotification_call(receiverId, title, message, type, callerId, senderName, senderAvatar);
//           logger.info(`Push notification sent to User ${receiverId}`);
//         }

//         const cleanupTimeout = () => {
//           logger.info(`Call attempt cleared for offline user ${receiverId}`);
//         };

//         // Set up cleanup listeners
//         socket.once('acceptCall', cleanupTimeout);
//         socket.once('rejectCall', cleanupTimeout);
//         socket.once('endCall', cleanupTimeout);

//       } catch (error) {
//         logger.error(`Failed to send push notification: ${error.message}`);
//         socket.emit('notificationError', {
//           receiverId,
//           message: 'Failed to send call notification'
//         });
//       }
//     }


//     function cleanupCallState(callerId, receiverId) {
//       const callLockKey = `${callerId}_${receiverId}`;
//       delete callLocks[callLockKey];
//       delete activeCalls[callerId];
//       delete activeCalls[receiverId];
//     }

//     // Handle WebRTC offer
//     // WebRTC offer handler
//     socket.on('offer', async ({ offer, callerId, receiverId }) => {
//       const callKey = `${callerId}_${receiverId}`;

//       try {
//         logger.info(`User ${callerId} sending offer to User ${receiverId}`);

//         // Verify call setup state
//         if (!users[receiverId]) {
//           socket.emit('userUnavailable', {
//             receiverId,
//             message: 'Receiver is not connected'
//           });
//           logger.warn(`Receiver ${receiverId} not found during offer`);
//           cleanupCallState(callerId, receiverId);
//           return;
//         }

//         // Check if users are already in calls
//         if (activeCalls[receiverId] && activeCalls[receiverId] !== callerId) {
//           socket.emit('userBusy', {
//             receiverId,
//             message: 'Receiver is in another call'
//           });
//           logger.warn(`Receiver ${receiverId} is busy in another call`);
//           cleanupCallState(callerId, receiverId);
//           return;
//         }

//         // Set active call status
//         activeCalls[callerId] = receiverId;
//         activeCalls[receiverId] = callerId;

//         // Create call session record
//         try {
//           await CallSession.create({
//             callId: callKey,
//             caller: callerId,
//             receiver: receiverId,
//             startTime: new Date(),
//             status: 'connecting'
//           });
//         } catch (error) {
//           logger.error(`Failed to create call session record: ${error.message}`);
//         }

//         // Set offer timeout
//         const offerTimeout = setTimeout(() => {
//           if (!callConnected[callKey]) {
//             socket.emit('offerTimeout', { receiverId });
//             cleanupCallState(callerId, receiverId);
//             logger.warn(`Offer timeout for call ${callKey}`);
//           }
//         }, 15000); // 15 second timeout for offer acceptance

//         // Send offer to all receiver's sockets
//         Array.from(users[receiverId]).forEach((socketId) => {
//           socket.to(socketId).emit('offer', {
//             offer,
//             callerId,
//             callKey
//           });
//         });

//         logger.info(`Offer sent to User ${receiverId}`);

//         // Clear timeout on answer received
//         socket.once('answer', () => {
//           clearTimeout(offerTimeout);
//           callConnected[callKey] = true;
//         });

//       } catch (error) {
//         logger.error(`Error in offer handler: ${error.message}`);
//         socket.emit('callError', {
//           message: 'Failed to process offer',
//           error: error.message
//         });
//         cleanupCallState(callerId, receiverId);
//       }
//     });

//     // WebRTC answer handler
//     socket.on('answer', async ({ answer, receiverId, callerId }) => {
//       const callKey = `${callerId}_${receiverId}`;

//       try {
//         logger.info(`User ${receiverId} sending answer to User ${callerId}`);

//         // Verify call state
//         if (!activeCalls[callerId] || activeCalls[callerId] !== receiverId) {
//           socket.emit('callError', {
//             message: 'No active call found',
//             callerId,
//             receiverId
//           });
//           logger.warn(`Invalid call state for answer: ${callKey}`);
//           return;
//         }

//         // Verify caller is still connected
//         if (!users[callerId]) {
//           socket.emit('callerDisconnected', {
//             callerId,
//             message: 'Caller has disconnected'
//           });
//           logger.warn(`Caller ${callerId} disconnected before answer`);
//           cleanupCallState(callerId, receiverId);
//           return;
//         }

//         // Update call session status
//         try {
//           await CallSession.findOneAndUpdate(
//             { callId: callKey },
//             {
//               status: 'connected',
//               answeredAt: new Date()
//             }
//           );
//         } catch (error) {
//           logger.error(`Failed to update call session: ${error.message}`);
//         }

//         // Send answer to all caller's sockets
//         Array.from(users[callerId]).forEach((socketId) => {
//           socket.to(socketId).emit('answer', {
//             answer,
//             receiverId,
//             callKey
//           });
//         });

//         // Start call duration timer
//         startCallTimer(callKey);

//         logger.info(`Answer sent to User ${callerId} for call ${callKey}`);

//       } catch (error) {
//         logger.error(`Error in answer handler: ${error.message}`);
//         socket.emit('callError', {
//           message: 'Failed to process answer',
//           error: error.message
//         });
//         cleanupCallState(callerId, receiverId);
//       }
//     });

//     // Helper function to cleanup call state
//     function cleanupCallState(callerId, receiverId) {
//       const callKey = `${callerId}_${receiverId}`;
//       delete activeCalls[callerId];
//       delete activeCalls[receiverId];
//       delete callConnected[callKey];
//       clearTimeout(callTimers[callKey]);
//       delete callTimers[callKey];
//     }

//     // Helper function to start call timer
//     function startCallTimer(callKey) {
//       callTimers[callKey] = setInterval(async () => {
//         try {
//           const session = await CallSession.findOne({ callId: callKey });
//           if (session) {
//             session.duration = Math.floor((new Date() - session.startTime) / 1000);
//             await session.save();
//           }
//         } catch (error) {
//           logger.error(`Error updating call duration: ${error.message}`);
//         }
//       }, 60000); // Update duration every minute
//     }

//     // Handle ICE candidates offer
//     socket.on('iceCandidate', ({ candidate, callerId, receiverId }) => {
//       const callKey = `${callerId}_${receiverId}`;

//       try {
//         // Verify active call state
//         if (!activeCalls[callerId] || activeCalls[callerId] !== receiverId) {
//           logger.warn(`Ignored ICE candidate - no active call between ${callerId} and ${receiverId}`);
//           return;
//         }

//         // Verify receiver is still connected
//         if (!users[receiverId] || users[receiverId].length === 0) {
//           logger.warn(`Cannot relay ICE candidate - receiver ${receiverId} is not connected`);
//           socket.emit('peerDisconnected', {
//             peerId: receiverId,
//             message: 'Peer disconnected during ICE negotiation'
//           });
//           cleanupCallState(callerId, receiverId);
//           return;
//         }

//         // Set timeout for ICE gathering if not already set
//         if (!iceTimeouts[callKey]) {
//           iceTimeouts[callKey] = setTimeout(() => {
//             if (activeCalls[callerId] === receiverId) {
//               logger.warn(`ICE gathering timeout for call ${callKey}`);
//               socket.emit('iceGatheringTimeout', {
//                 callerId,
//                 receiverId,
//                 message: 'ICE candidate gathering timed out'
//               });
//               cleanupCallState(callerId, receiverId);
//             }
//           }, 10000); // 10 second timeout for ICE gathering
//         }

//         // Relay ICE candidate to all receiver's sockets
//         users[receiverId].forEach((socketId) => {
//           socket.to(socketId).emit('iceCandidate', {
//             candidate,
//             callerId,
//             callKey
//           });
//         });

//         logger.debug(`ICE candidate relayed from ${callerId} to ${receiverId}`);

//         // Clear ICE timeout when we receive the last candidate
//         if (candidate.candidate === '') {
//           logger.info(`ICE gathering completed for call ${callKey}`);
//           clearTimeout(iceTimeouts[callKey]);
//           delete iceTimeouts[callKey];
//         }

//       } catch (error) {
//         logger.error(`Error in iceCandidate handler: ${error.message}`);
//         socket.emit('webrtcError', {
//           type: 'ice_error',
//           message: 'Failed to process ICE candidate',
//           callerId,
//           receiverId
//         });

//         // Cleanup on fatal errors
//         if (error.fatal) {
//           cleanupCallState(callerId, receiverId);
//         }
//       }
//     });

//     // ICE connection state change handler
//     socket.on('iceConnectionStateChange', ({ state, callerId, receiverId }) => {
//       const callKey = `${callerId}_${receiverId}`;

//       try {
//         logger.info(`ICE connection state changed to ${state} for call ${callKey}`);
//         iceStates[callKey] = state;

//         // Handle failed ICE connection
//         if (state === 'failed' || state === 'disconnected') {
//           logger.warn(`ICE connection ${state} for call ${callKey}`);
//           socket.emit('iceConnectionFailed', {
//             callerId,
//             receiverId,
//             state
//           });
//           cleanupCallState(callerId, receiverId);
//         }

//       } catch (error) {
//         logger.error(`Error handling ICE state change: ${error.message}`);
//       }
//     });

//     // Helper function to cleanup call state
//     function cleanupCallState(callerId, receiverId) {
//       const callKey = `${callerId}_${receiverId}`;

//       // Clear any pending timeouts
//       if (iceTimeouts[callKey]) {
//         clearTimeout(iceTimeouts[callKey]);
//         delete iceTimeouts[callKey];
//       }

//       // Clear call states
//       delete activeCalls[callerId];
//       delete activeCalls[receiverId];
//       delete iceStates[callKey];

//       logger.info(`Cleaned up call state for ${callKey}`);
//     }





//     // State management objects


//     // Call acceptance handler with improved state management
//     socket.on('acceptCall', async ({ receiverId, callerId }) => {
//       const callKey = `${receiverId}_${callerId}`;

//       try {
//         logger.info(`User ${receiverId} accepting call from User ${callerId}`);

//         // Verify call state
//         if (!users[callerId]) {
//           logger.warn(`Cannot accept call - caller ${callerId} is not connected`);
//           socket.emit('callError', {
//             message: 'Caller has disconnected',
//             code: 'CALLER_DISCONNECTED'
//           });
//           cleanupCallState(callerId, receiverId);
//           return;
//         }

//         // Check if either user is already in another call
//         if (activeCalls[receiverId] && activeCalls[receiverId] !== callerId) {
//           logger.warn(`User ${receiverId} is already in another call`);
//           socket.emit('callError', {
//             message: 'You are already in another call',
//             code: 'ALREADY_IN_CALL'
//           });
//           return;
//         }

//         if (activeCalls[callerId] && activeCalls[callerId] !== receiverId) {
//           logger.warn(`Caller ${callerId} is already in another call`);
//           socket.emit('callError', {
//             message: 'Caller is already in another call',
//             code: 'CALLER_BUSY'
//           });
//           return;
//         }

//         // Set call states
//         activeCalls[callerId] = receiverId;
//         activeCalls[receiverId] = callerId;

//         callStates[callKey] = {
//           status: 'connecting',
//           startTime: new Date(),
//           lastActiveTime: new Date()
//         };

//         // Record call timing
//         callTimings[callKey] = {
//           startTime: new Date(),
//           acceptedAt: new Date()
//         };

//         // Set call activity timeout
//         setCallActivityTimeout(callKey, callerId, receiverId);

//         // Notify all caller's sockets
//         if (users[callerId]?.length > 0) {
//           users[callerId].forEach((socketId) => {
//             // Notify call acceptance
//             socket.to(socketId).emit('callAccepted', {
//               receiverId,
//               receiverSocketId: socket.id,
//               timestamp: callTimings[callKey].acceptedAt
//             });

//             // Notify active call status
//             socket.to(socketId).emit('activeCall', {
//               callerId,
//               receiverId,
//               receiverSocketId: socket.id,
//               callKey
//             });
//           });

//           logger.info(`Call acceptance notifications sent to User ${callerId}`);

//           // Stop caller tune
//           socket.emit('stopCallerTune', { callerId });

//           // Emit call start event to both parties
//           emitCallStartEvent(socket, callerId, receiverId, callKey);

//         } else {
//           logger.warn(`No active sockets found for caller ${callerId}`);
//           socket.emit('callError', {
//             message: 'Caller is no longer connected',
//             code: 'CALLER_UNAVAILABLE'
//           });
//           cleanupCallState(callerId, receiverId);
//           return;
//         }

//         logger.info(`Call ${callKey} is now active`);

//       } catch (error) {
//         logger.error(`Error in acceptCall handler: ${error.message}`);
//         socket.emit('callError', {
//           message: 'Failed to accept call. Please try again.',
//           code: 'ACCEPT_FAILED',
//           error: error.message
//         });
//         cleanupCallState(callerId, receiverId);
//       }
//     });

//     // Helper function to set call activity timeout
//     function setCallActivityTimeout(callKey, callerId, receiverId) {
//       // Clear any existing timeout
//       if (callStates[callKey]?.activityTimeout) {
//         clearTimeout(callStates[callKey].activityTimeout);
//       }

//       // Set new timeout
//       callStates[callKey].activityTimeout = setTimeout(() => {
//         if (callStates[callKey]?.status === 'connecting') {
//           logger.warn(`Call ${callKey} timed out during connection`);
//           socket.emit('callTimeout', {
//             callerId,
//             receiverId,
//             message: 'Call timed out during connection'
//           });
//           cleanupCallState(callerId, receiverId);
//         }
//       }, 30000); // 30 second timeout for call connection
//     }

//     // Helper function to emit call start event
//     function emitCallStartEvent(socket, callerId, receiverId, callKey) {
//       const callStartEvent = {
//         callKey,
//         startTime: callTimings[callKey].startTime,
//         participants: {
//           caller: callerId,
//           receiver: receiverId
//         }
//       };

//       // Emit to caller
//       if (users[callerId]) {
//         users[callerId].forEach(socketId => {
//           socket.to(socketId).emit('callStarted', callStartEvent);
//         });
//       }

//       // Emit to receiver
//       if (users[receiverId]) {
//         users[receiverId].forEach(socketId => {
//           socket.to(socketId).emit('callStarted', callStartEvent);
//         });
//       }
//     }

//     // Helper function to cleanup call state
//     function cleanupCallState(callerId, receiverId) {
//       const callKey = `${receiverId}_${callerId}`;

//       // Clear any timeouts
//       if (callStates[callKey]?.activityTimeout) {
//         clearTimeout(callStates[callKey].activityTimeout);
//       }

//       // Clear all call states
//       delete activeCalls[callerId];
//       delete activeCalls[receiverId];
//       delete callTimings[callKey];
//       delete callStates[callKey];

//       logger.info(`Cleaned up call state for ${callKey}`);
//     }

//     // socket.on('acceptCall', async ({ receiverId, callerId }) => {
//     //   try {
//     //     logger.info(`User ${receiverId} accepted call from User ${callerId}`);

//     //     // Store start time as a Date object
//     //     const callKey = `${receiverId}_${callerId}`;
//     //     logger.info(`callKey ${callKey}`);

//     //     callTimings[callKey] = {
//     //       startTime: new Date() // Start time as a Date object
//     //     };

//     //     // Notify the caller that the call has been accepted
//     //     if (users[callerId]) {
//     //       users[callerId].forEach((socketId) => {
//     //         socket.to(socketId).emit('callAccepted', {
//     //           receiverId,
//     //           socketId: socket.id
//     //         });
//     //         socket.to(socketId).emit('activeCall',{
//     //           callerId,
//     //           receiverId,
//     //           socketId:socket.id
//     //         }
//     //       });

//     //       // Stop the caller's tune after call acceptance
//     //       socket.emit('stopCallerTune', { callerId });
//     //     }
//     //   } catch (error) {
//     //     logger.error(`Error in acceptCall handler: ${error.message}`);
//     //     socket.emit('callError', { message: 'Failed to accept call' });
//     //   }
//     // });



//     // Handle call rejection



//     socket.on('missedcall', async ({ receiverId, callerId }) => {
//       try {
//         // Validate input
//         if (!receiverId || !callerId) {
//           return socket.emit('callError', { message: 'Invalid call parameters' });
//         }

//         // Fetch user details
//         const caller = await User.findById(callerId).select('username name profilePicture');
//         const receiver = await User.findById(receiverId).select('username deviceToken notificationSettings -_id');

//         if (!caller || !receiver) {
//           return socket.emit('callError', { message: 'Caller or receiver not found' });
//         }

//         const callerName = caller.name || caller.username;

//         // Notify receiver via socket
//         const receiverSockets = users[receiverId];
//         if (receiverSockets?.length) {
//           // Send socket notification to all connected sockets for the receiver
//           receiverSockets.forEach((socketId) => {
//             socket.to(socketId).emit('callMissed', {
//               callerId,
//               callerName,
//               callerPicture: caller.profilePicture,
//               timestamp: new Date(),
//             });
//           });
//         }

//         // Send push notification (only once)
//         if (receiver.deviceToken && receiver.notificationSettings?.missedCalls !== false) {
//           await sendNotification_call(
//             receiverId,
//             'Missed Call',
//             `You missed a call from ${callerName}`,
//             'missed_call',
//             receiverId,
//             callerName,
//             caller.profilePicture
//           );
//         }

//         // Log missed call for caller
//         const logForCaller = await CallLog.create({
//           caller: new mongoose.Types.ObjectId(callerId),
//           receiver: new mongoose.Types.ObjectId(receiverId),
//           startTime: new Date(),
//           endTime: new Date(),
//           duration: 0,
//           status: 'missed',
//         });

//         // Log missed call for receiver
//         const logForReceiver = await CallLog.create({
//           caller: new mongoose.Types.ObjectId(receiverId),
//           receiver: new mongoose.Types.ObjectId(callerId),
//           startTime: new Date(),
//           endTime: new Date(),
//           duration: 0,
//           status: 'missed',
//         });

//         console.log('Missed call logs created:', { logForCaller, logForReceiver });
//       } catch (error) {
//         console.error('Error processing missed call:', error);
//         socket.emit('callError', { message: 'Failed to process missed call' });
//       }
//     });



//     socket.on('rejectCall', async ({ receiverId, callerId }) => {
//       const callKey = `${receiverId}_${callerId}`;

//       try {
//         logger.info(`User ${receiverId} rejecting call from User ${callerId}`);

//         // Verify call state
//         if (!users[callerId]) {
//           logger.warn(`Caller ${callerId} not found while rejecting call`);
//           cleanupCallState(callerId, receiverId);
//           return;
//         }

//         // Update call state
//         callStates[callKey] = {
//           status: 'rejected',
//           endTime: new Date(),
//           endedBy: receiverId,
//           reason: 'rejected_by_receiver'
//         };

//         // Notify caller about rejection
//         if (users[callerId]?.length > 0) {
//           users[callerId].forEach((socketId) => {
//             socket.to(socketId).emit('callRejected', {
//               receiverId,
//               timestamp: callStates[callKey].endTime,
//               reason: 'rejected_by_receiver'
//             });
//           });
//           logger.info(`Rejection notification sent to User ${callerId}`);
//         }

//         // Stop caller tune
//         socket.emit('stopCallerTune', { callerId });

//         try {
//           // Create call log
//           await CallLog.create({
//             caller: new mongoose.Types.ObjectId(callerId),
//             receiver: new mongoose.Types.ObjectId(receiverId),
//             startTime: new Date(),
//             endTime: new Date(),
//             duration: 0,
//             status: 'rejected',

//           });
//           logger.info(`Call log created for rejected call ${callKey}`);
//         } catch (dbError) {
//           logger.error(`Failed to create call log: ${dbError.message}`);
//         }

//         // Cleanup call state
//         cleanupCallState(callerId, receiverId);

//       } catch (error) {
//         logger.error(`Error in rejectCall handler: ${error.message}`);
//         socket.emit('callError', {
//           message: 'Failed to reject call',
//           code: 'REJECT_FAILED',
//           error: error.message
//         });
//         cleanupCallState(callerId, receiverId);
//       }
//     });

//     // Call end handler
//     socket.on('endCall', async ({ receiverId, callerId }) => {
//       const callKey = `${receiverId}_${callerId}`;
//       const reverseCallKey = `${callerId}_${receiverId}`;

//       try {
//         logger.info(`Ending call between ${callerId} and ${receiverId}`);

//         // Verify active call
//         if (!isCallActive(callerId, receiverId)) {
//           logger.warn(`No active call found between ${callerId} and ${receiverId}`);
//           socket.emit('callError', {
//             message: 'No active call found',
//             code: 'NO_ACTIVE_CALL'
//           });
//           return;
//         }

//         // Get call timing information
//         const startTime = callTimings[callKey]?.startTime || callTimings[reverseCallKey]?.startTime;
//         if (!startTime) {
//           logger.warn(`Start time not found for call ${callKey}`);
//           cleanupCallState(callerId, receiverId);
//           return;
//         }

//         const endTime = new Date();
//         const duration = Math.round((endTime - new Date(startTime)) / 1000);

//         // Update call state
//         callStates[callKey] = {
//           status: 'completed',
//           endTime: endTime,
//           duration: duration,
//         };

//         // Notify other party about call end
//         notifyCallEnd(socket, callerId, receiverId);

//         try {
//           // Create call log
//           await CallLog.create({
//             caller: new mongoose.Types.ObjectId(callerId),
//             receiver: new mongoose.Types.ObjectId(receiverId),
//             startTime: new Date(startTime),
//             endTime: endTime,
//             duration: duration,
//             status: 'completed',

//           });
//           logger.info(`Call log created for completed call ${callKey}`);
//         } catch (dbError) {
//           logger.error(`Failed to create call log: ${dbError.message}`);
//         }

//         // Cleanup call state
//         cleanupCallState(callerId, receiverId);

//       } catch (error) {
//         logger.error(`Error in endCall handler: ${error.message}`);
//         socket.emit('callError', {
//           message: 'Failed to end call properly',
//           code: 'END_FAILED',
//           error: error.message
//         });
//         cleanupCallState(callerId, receiverId);
//       }
//     });

//     // Helper function to check if call is active
//     function isCallActive(callerId, receiverId) {
//       return activeCalls[callerId] === receiverId || activeCalls[receiverId] === callerId;
//     }

//     // Helper function to notify call end
//     function notifyCallEnd(socket, callerId, receiverId) {
//       // Notify receiver
//       if (users[receiverId]?.length > 0) {
//         users[receiverId].forEach((socketId) => {
//           socket.to(socketId).emit('callEnded', {
//             callerId,
//             timestamp: new Date(),
//             reason: 'ended_by_caller'
//           });

//           socket.to(socketId).emit('inactiveCall', {
//             callerId,
//             receiverId,
//             socketId: socket.id
//           });
//         });
//         logger.info(`Call end notification sent to User ${receiverId}`);
//       }

//       // Notify caller
//       if (users[callerId]?.length > 0) {
//         users[callerId].forEach((socketId) => {
//           socket.to(socketId).emit('inactiveCall', {
//             callerId,
//             receiverId,
//             socketId: socket.id
//           });
//         });
//       }
//     }

//     // Helper function to cleanup call state
//     function cleanupCallState(callerId, receiverId) {
//       const callKey = `${receiverId}_${callerId}`;
//       const reverseCallKey = `${callerId}_${receiverId}`;

//       // Clear all call states
//       delete activeCalls[callerId];
//       delete activeCalls[receiverId];
//       delete callTimings[callKey];
//       delete callTimings[reverseCallKey];
//       delete callStates[callKey];
//       delete callStates[reverseCallKey];

//       logger.info(`Cleaned up call state for ${callKey}`);
//     }


//     // Update disconnect handler to handle call timings cleanup

//     // socket.on('disconnect', async () => {
//     //   logger.info(`Socket disconnected: ${socket.id}`);

//     //   // Find and remove the disconnected socket
//     //   let disconnectedUserId;
//     //   for (const [userId, socketIds] of Object.entries(users)) {
//     //     const index = socketIds.indexOf(socket.id);
//     //     if (index !== -1) {
//     //       socketIds.splice(index, 1);
//     //       disconnectedUserId = userId;

//     //       // Remove user entry if no sockets left
//     //       if (socketIds.length === 0) {
//     //         delete users[userId];

//     //         // Update user status to offline in database
//     //         try {
//     //           await User.findByIdAndUpdate(
//     //             disconnectedUserId,
//     //             {
//     //               status: 'offline',
//     //             }
//     //           );

//     //           // Broadcast offline status to other users
//     //           socket.broadcast.emit('userStatusChanged', {
//     //             userId: disconnectedUserId,
//     //             status: 'offline'
//     //           });
//     //         } catch (error) {
//     //           logger.error(`Error updating user offline status: ${error.message}`);
//     //         }
//     //       }
//     //       break;
//     //     }
//     //   }

//     //   // End any active calls for the disconnected user
//     //   if (disconnectedUserId && activeCalls[disconnectedUserId]) {
//     //     const otherUserId = activeCalls[disconnectedUserId];

//     //     // Log call if it was ongoing
//     //     const callKey = `${disconnectedUserId}_${otherUserId}`;
//     //     const reverseCallKey = `${otherUserId}_${disconnectedUserId}`;

//     //     if (callTimings[callKey] || callTimings[reverseCallKey]) {
//     //       const endTime = new Date();
//     //       const startTime = callTimings[callKey]?.startTime || callTimings[reverseCallKey]?.startTime;
//     //       const duration = Math.floor((endTime - startTime) / 1000);

//     //       // Create call log for disconnected call
//     //       CallLog.create({
//     //         caller: new mongoose.Types.ObjectId(disconnectedUserId),
//     //         receiver: new mongoose.Types.ObjectId(otherUserId),
//     //         startTime,
//     //         endTime,
//     //         duration,
//     //         status: 'disconnected'
//     //       }).catch(error => {
//     //         logger.error(`Error logging disconnected call: ${error.message}`);
//     //       });

//     //       // Clean up call timings
//     //       delete callTimings[callKey];
//     //       delete callTimings[reverseCallKey];
//     //     }

//     //     // Notify other user about call end
//     //     if (users[otherUserId]) {
//     //       users[otherUserId].forEach((socketId) => {
//     //         socket.to(socketId).emit('callEnded', {
//     //           callerId: disconnectedUserId
//     //         });
//     //       });
//     //     }

//     //     delete activeCalls[disconnectedUserId];
//     //     delete activeCalls[otherUserId];
//     //   }
//     // });


//     // socket.on('disconnect', async () => {
//     //   logger.info(`Socket disconnected: ${socket.id}`);
//     //   removeUserFromQueue(socket.id);
//     //   console.log('Current queue:', userQueue);

//     //   let disconnectedUserId;
//     //   for (const [userId, socketIds] of Object.entries(users)) {
//     //     const index = socketIds.indexOf(socket.id);
//     //     if (index !== -1) {
//     //       socketIds.splice(index, 1);
//     //       disconnectedUserId = userId;

//     //       if (socketIds.length === 0) {
//     //         delete users[userId];
//     //         try {
//     //           const updatedUser = await User.findOneAndUpdate(
//     //             { _id: disconnectedUserId, userType: 'CALLER' },
//     //             { status: 'offline' },
//     //             { new: true }
//     //           );
//     //           if (updatedUser) {
//     //             io.emit('userStatusChanged', { userId: disconnectedUserId, status: 'offline' });
//     //           }

//     //         } catch (error) {
//     //           logger.error(`Failed to update offline status for user ${disconnectedUserId}: ${error.message}`);
//     //         }
//     //       }
//     //       break;
//     //     }
//     //   }

//     //   if (disconnectedUserId && activeCalls[disconnectedUserId]) {
//     //     const otherUserId = activeCalls[disconnectedUserId];
//     //     const callKey = `${disconnectedUserId}_${otherUserId}`;
//     //     const reverseCallKey = `${otherUserId}_${disconnectedUserId}`;
//     //     const callStartTime = callTimings[callKey]?.startTime || callTimings[reverseCallKey]?.startTime;

//     //     if (callStartTime) {
//     //       const endTime = new Date();
//     //       const duration = Math.floor((endTime - callStartTime) / 1000);

//     //       try {
//     //         await CallLog.create({
//     //           caller: new mongoose.Types.ObjectId(disconnectedUserId),
//     //           receiver: new mongoose.Types.ObjectId(otherUserId),
//     //           startTime: callStartTime,
//     //           endTime,
//     //           duration,
//     //           status: 'disconnected',
//     //         });
//     //       } catch (error) {
//     //         logger.error(`Failed to log call for disconnected user ${disconnectedUserId}: ${error.message}`);
//     //       }

//     //       delete callTimings[callKey];
//     //       delete callTimings[reverseCallKey];
//     //     }

//     //     if (users[otherUserId]) {
//     //       users[otherUserId].forEach((socketId) => {
//     //         socket.to(socketId).emit('callEnded', { callerId: disconnectedUserId });
//     //       });
//     //     }

//     //     delete activeCalls[disconnectedUserId];
//     //     delete activeCalls[otherUserId];
//     //   }
//     // });

//     // Disconnect handler with queue management and call logging
//     socket.on('disconnect', async () => {
//       try {
//         logger.info(`Socket disconnected: ${socket.id}`);

//         // Remove user from queue
//         removeUserFromQueue(socket.id);
//         logger.info('Current queue:', userQueue);

//         let disconnectedUserId;

//         // Find and remove the socket ID from users
//         for (const [userId, socketIds] of Object.entries(users)) {
//           const index = socketIds.indexOf(socket.id);
//           if (index !== -1) {
//             // Remove this socket from user's socket list
//             socketIds.splice(index, 1);
//             disconnectedUserId = userId;

//             // If this was the user's last socket, handle complete disconnection
//             if (socketIds.length === 0) {
//               delete users[userId];

//               try {
//                 // Update user status to offline in database
//                 const updatedUser = await User.findOneAndUpdate(
//                   { _id: disconnectedUserId },
//                   { status: 'offline', lastSeen: new Date() },
//                   { new: true }
//                 );

//                 if (updatedUser) {
//                   // Broadcast status change to all connected clients
//                   io.emit('userStatusChanged', {
//                     userId: disconnectedUserId,
//                     status: 'offline',
//                     lastSeen: updatedUser.lastSeen
//                   });
//                   logger.info(`User ${disconnectedUserId} is now offline`);
//                 }
//               } catch (error) {
//                 logger.error(`Failed to update offline status for user ${disconnectedUserId}: ${error.message}`);
//               }
//             } else {
//               logger.info(`User ${disconnectedUserId} still has ${socketIds.length} active connections`);
//             }
//             break;
//           }
//         }

//         // Handle active call disconnection if user was in a call
//         if (disconnectedUserId && activeCalls[disconnectedUserId]) {
//           await handleCallDisconnection(disconnectedUserId, socket);
//         }

//       } catch (error) {
//         logger.error(`Error in disconnect handler: ${error.message}`);
//       }
//     });

//     // Helper function to handle call disconnection and logging
//     async function handleCallDisconnection(disconnectedUserId, socket) {
//       try {
//         const otherUserId = activeCalls[disconnectedUserId];
//         const callKey = `${disconnectedUserId}_${otherUserId}`;
//         const reverseCallKey = `${otherUserId}_${disconnectedUserId}`;

//         // Get call timing information
//         const callStartTime = callTimings[callKey]?.startTime || callTimings[reverseCallKey]?.startTime;

//         if (callStartTime) {
//           const endTime = new Date();
//           const duration = Math.floor((endTime - callStartTime) / 1000);

//           // Create call log entry
//           try {
//             await CallLog.create({
//               caller: new mongoose.Types.ObjectId(disconnectedUserId),
//               receiver: new mongoose.Types.ObjectId(otherUserId),
//               startTime: callStartTime,
//               endTime,
//               duration,
//               status: 'disconnected',
//               disconnectedBy: disconnectedUserId
//             });
//             logger.info(`Call log created for disconnected call between ${disconnectedUserId} and ${otherUserId}`);
//           } catch (error) {
//             logger.error(`Failed to create call log: ${error.message}`);
//           }

//           // Cleanup call timing records
//           delete callTimings[callKey];
//           delete callTimings[reverseCallKey];
//         }

//         // Notify other user about call end
//         if (users[otherUserId]?.length > 0) {
//           users[otherUserId].forEach((socketId) => {
//             socket.to(socketId).emit('callEnded', {
//               callerId: disconnectedUserId,
//               reason: 'disconnected'
//             });
//           });
//           logger.info(`Notified user ${otherUserId} about call end`);
//         }

//         // Cleanup call states
//         delete activeCalls[disconnectedUserId];
//         delete activeCalls[otherUserId];

//       } catch (error) {
//         logger.error(`Error in handleCallDisconnection: ${error.message}`);
//       }
//     }

//     // Helper function to remove user from queue
//     function removeUserFromQueue(socketId) {
//       const index = userQueue.findIndex(user => user.socketId === socketId);
//       if (index !== -1) {
//         userQueue.splice(index, 1);
//         logger.info(`Removed socket ${socketId} from queue`);
//       }
//     }


//   });
// };


// async function sendNotification_call(userId, title, message, type, callerId, senderName, senderAvatar) {
//   try {
//     const user = await User.findById(userId);
//     if (!user || !user.deviceToken) {
//       logger.error(`No device token found for user: ${userId}`);
//       return;
//     }

//     const payload = {
//       notification: {
//         title: title || "Incoming Voice Call",
//         body: message || `${senderName} is calling you`
//       },
//       data: {
//         screen: 'incoming_Call',
//         params: JSON.stringify({
//           user_id: userId,
//           type: 'voice',
//           agent_id: callerId,
//           username: senderName,
//           imageurl: senderAvatar || 'https://investogram.ukvalley.com/avatars/default.png',
//           timestamp: Date.now().toString(),
//           call_id: `${callerId}_${Date.now()}`,
//           channel_id: 'EarforYou123',
//           priority: 'high',
//           notification_type: 'call',
//           action_answer: 'Answer Call',
//           action_decline: 'Decline Call'
//         })
//       },
//       android: {
//         priority: 'high',
//         ttl: 60000,
//         notification: {
//           channel_id: 'EarforYou123',
//           priority: 'high',
//           default_sound: true,
//           notification_priority: 'PRIORITY_HIGH'
//         }
//       },
//       apns: {
//         payload: {
//           aps: {
//             alert: {
//               title: title || "Incoming Voice Call",
//               body: message || `${senderName} is calling you`
//             },
//             sound: 'default',
//             category: 'VOICE_CALL',
//             'content-available': 1,
//             priority: '10'
//           }
//         },
//         headers: {
//           'apns-push-type': 'background',
//           'apns-priority': '10',
//           'apns-expiration': (Math.floor(Date.now() / 1000) + 60).toString()
//         }
//       },
//       token: user.deviceToken
//     };

//     logger.info(`Sending voice call notification to user ${userId}`);
//     const response = await admin.messaging().send(payload);
//     logger.info(`Voice call notification sent successfully: ${response}`);
//     return response;
//   } catch (error) {
//     logger.error(`Failed to send voice call notification: ${error.message}`);
//     throw error;
//   }
// }


// async function sendNotification(userId, title, message, type, receiverId, senderName, senderAvatar) {
//   try {
//     // Fetch the user from the database
//     const user = await User.findById(userId);
//     if (!user || !user.deviceToken) {
//       console.error("No device token found for user:", userId);
//       return;
//     }

//     const deviceToken = user.deviceToken;

//     // Construct the payload for FCM
//     const payload = {
//       notification: {
//         title: title,
//         body: message,
//       },
//       data: {
//         screen: 'incoming_Call', // Target screen
//         params: JSON.stringify({
//           user_id: userId, // Include Call ID
//           type: type, // Type of call
//           agent_id: receiverId, // Receiver ID
//           username: senderName, // Sender name
//           imageurl: senderAvatar || 'https://investogram.ukvalley.com/avatars/default.png', // Sender avatar with default fallback
//         }),
//         // Add any additional parameters if needed
//       },
//       token: deviceToken,
//     };
//     logger.info(`Push notification sent to User  in  notification  function`);

//     // Send the notification
//     const response = await admin.messaging().send(payload);
//     console.log("Notification sent successfully:", response);
//   } catch (error) {
//     console.error("Error sending notification:", error);
//   }
// }


// // async function sendMNotification(userId, title, message, type, receiverId, senderName, senderAvatar) {
// //   try {
// //     // Fetch the user from the database
// //     const user = await User.findById(userId);
// //     if (!user || !user.deviceToken) {
// //       console.error("No device token found for user:", userId);
// //       return;
// //     }

// //     const deviceToken = user.deviceToken;

// //     // Construct the payload for FCM
// //     const payload = {
// //       notification: {
// //         title: title,
// //         body: message,
// //       },
// //       data: {
// //         screen: 'misscall', // Target screen
// //         params: JSON.stringify({
// //           user_id: userId, // Include Call ID
// //           type: type, // Type of call
// //           agent_id: receiverId, // Receiver ID
// //           username: senderName, // Sender name
// //           imageurl: senderAvatar || 'https://investogram.ukvalley.com/avatars/default.png', // Sender avatar with default fallback
// //         }),
// //         // Add any additional parameters if needed
// //       },
// //       token: deviceToken,
// //     };
// //     logger.info(`Push notification sent to User  in  notification  function`);

// //     // Send the notification
// //     const response = await admin.messaging().send(payload);
// //     console.log("Notification sent successfully:", response);
// //   } catch (error) {
// //     console.error("Error sending notification:", error);
// //   }
// // }








// // // Helper function to validate call parameters
// // const validateCallParams = (receiverId, callerId) => {
// //   if (!receiverId || !callerId) {
// //     throw new Error('Missing required parameters: receiverId or callerId');
// //   }
// // };

// // // Helper function to mark a call as missed in the database
// // const markCallAsMissed = async (callerId, receiverId, startTime) => {
// //   try {
// //     await CallLog.create({
// //       caller: callerId,
// //       receiver: receiverId,
// //       status: 'missed',
// //       startTime: startTime || new Date(),
// //       endTime: new Date(),
// //       duration: 0,
// //     });
// //     logger.info(`Missed call logged in database: Caller: ${callerId}, Receiver: ${receiverId}`);
// //   } catch (error) {
// //     logger.error(`Error saving missed call to database: ${error.message}`);
// //     throw new Error('Failed to log missed call');
// //   }
// // };


